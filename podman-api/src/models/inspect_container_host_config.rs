/*
 * supports a RESTful API for the Libpod library
 *
 * This documentation describes the Podman v2.x+ RESTful API. It consists of a Docker-compatible API and a Libpod API providing support for Podmanâ€™s unique features such as pods.  To start the service and keep it running for 5,000 seconds (-t 0 runs forever):  podman system service -t 5000 &  You can then use cURL on the socket using requests documented below.  NOTE: if you install the package podman-docker, it will create a symbolic link for /run/docker.sock to /run/podman/podman.sock  NOTE: Some fields in the API response JSON are encoded as omitempty, which means that if said field has a zero value, they will not be encoded in the API response. This is a feature to help reduce the size of the JSON responses returned via the API.  NOTE: Due to the limitations of [go-swagger](https://github.com/go-swagger/go-swagger), some field values that have a complex type show up as null in the docs as well as in the API responses. This is because the zero value for the field type is null. The field description in the docs will state what type the field is expected to be for such cases.  See podman-system-service(1) for more information.  Quick Examples:  'podman info'  curl --unix-socket /run/podman/podman.sock http://d/v5.0.0/libpod/info  'podman pull quay.io/containers/podman'  curl -XPOST --unix-socket /run/podman/podman.sock -v 'http://d/v5.0.0/images/create?fromImage=quay.io%2Fcontainers%2Fpodman'  'podman list images'  curl --unix-socket /run/podman/podman.sock -v 'http://d/v5.0.0/libpod/images/json' | jq
 *
 * The version of the OpenAPI document: 5.0.0
 * Contact: podman@lists.podman.io
 * Generated by: https://openapi-generator.tech
 */

use crate::models;
use serde::{Deserialize, Serialize};

/// InspectContainerHostConfig : nolint:revive,stylecheck // Field names are fixed for compatibility and cannot be changed.
#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
pub struct InspectContainerHostConfig {
    /// Annotations are provided to the runtime when the container is started.
    #[serde(rename = "Annotations", skip_serializing_if = "Option::is_none")]
    pub annotations: Option<std::collections::HashMap<String, String>>,
    /// AutoRemove is whether the container will be automatically removed on exiting. It is not handled directly within libpod and is stored in an annotation.
    #[serde(rename = "AutoRemove", skip_serializing_if = "Option::is_none")]
    pub auto_remove: Option<bool>,
    /// Binds contains an array of user-added mounts. Both volume mounts and named volumes are included. Tmpfs mounts are NOT included. In 'docker inspect' this is separated into 'Binds' and 'Mounts' based on how a mount was added. We do not make this distinction and do not include a Mounts field in inspect. Format: <src>:<destination>[:<comma-separated options>]
    #[serde(rename = "Binds", skip_serializing_if = "Option::is_none")]
    pub binds: Option<Vec<String>>,
    /// BlkioDeviceReadBps is an array of I/O throttle parameters for individual device nodes. This specifically sets read rate cap in bytes per second for device nodes. As with BlkioWeightDevice, we pull the path from /sys/dev, and we don't guarantee the path will be identical to the original (though the node will be).
    #[serde(rename = "BlkioDeviceReadBps", skip_serializing_if = "Option::is_none")]
    pub blkio_device_read_bps: Option<Vec<models::InspectBlkioThrottleDevice>>,
    /// BlkioDeviceReadIOps is an array of I/O throttle parameters for individual device nodes. This specifically sets the read rate cap in iops per second for device nodes. As with BlkioWeightDevice, we pull the path from /sys/dev, and we don't guarantee the path will be identical to the original (though the node will be).
    #[serde(rename = "BlkioDeviceReadIOps", skip_serializing_if = "Option::is_none")]
    pub blkio_device_read_i_ops: Option<Vec<models::InspectBlkioThrottleDevice>>,
    /// BlkioDeviceWriteBps is an array of I/O throttle parameters for individual device nodes. this specifically sets write rate cap in bytes per second for device nodes. as with BlkioWeightDevice, we pull the path from /sys/dev, and we don't guarantee the path will be identical to the original (though the node will be).
    #[serde(rename = "BlkioDeviceWriteBps", skip_serializing_if = "Option::is_none")]
    pub blkio_device_write_bps: Option<Vec<models::InspectBlkioThrottleDevice>>,
    /// BlkioDeviceWriteIOps is an array of I/O throttle parameters for individual device nodes. This specifically sets the write rate cap in iops per second for device nodes. As with BlkioWeightDevice, we pull the path from /sys/dev, and we don't guarantee the path will be identical to the original (though the node will be).
    #[serde(rename = "BlkioDeviceWriteIOps", skip_serializing_if = "Option::is_none")]
    pub blkio_device_write_i_ops: Option<Vec<models::InspectBlkioThrottleDevice>>,
    /// BlkioWeight indicates the I/O resources allocated to the container. It is a relative weight in the scheduler for assigning I/O time versus other Cgroups.
    #[serde(rename = "BlkioWeight", skip_serializing_if = "Option::is_none")]
    pub blkio_weight: Option<i32>,
    /// BlkioWeightDevice is an array of I/O resource priorities for individual device nodes. Unfortunately, the spec only stores the device's Major/Minor numbers and not the path, which is used here. Fortunately, the kernel provides an interface for retrieving the path of a given node by major:minor at /sys/dev/. However, the exact path in use may not be what was used in the original CLI invocation - though it is guaranteed that the device node will be the same, and using the given path will be functionally identical.
    #[serde(rename = "BlkioWeightDevice", skip_serializing_if = "Option::is_none")]
    pub blkio_weight_device: Option<Vec<models::InspectBlkioWeightDevice>>,
    /// CapAdd is a list of capabilities added to the container. It is not directly stored by Libpod, and instead computed from the capabilities listed in the container's spec, compared against a set of default capabilities.
    #[serde(rename = "CapAdd", skip_serializing_if = "Option::is_none")]
    pub cap_add: Option<Vec<String>>,
    /// CapDrop is a list of capabilities removed from the container. It is not directly stored by libpod, and instead computed from the capabilities listed in the container's spec, compared against a set of default capabilities.
    #[serde(rename = "CapDrop", skip_serializing_if = "Option::is_none")]
    pub cap_drop: Option<Vec<String>>,
    /// Cgroup contains the container's cgroup. It is presently not populated. TODO.
    #[serde(rename = "Cgroup", skip_serializing_if = "Option::is_none")]
    pub cgroup: Option<String>,
    /// CgroupConf is the configuration for cgroup v2.
    #[serde(rename = "CgroupConf", skip_serializing_if = "Option::is_none")]
    pub cgroup_conf: Option<std::collections::HashMap<String, String>>,
    /// CgroupManager is the cgroup manager used by the container. At present, allowed values are either \"cgroupfs\" or \"systemd\".
    #[serde(rename = "CgroupManager", skip_serializing_if = "Option::is_none")]
    pub cgroup_manager: Option<String>,
    /// CgroupMode is the configuration of the container's cgroup namespace. Populated as follows: private - a cgroup namespace has been created host - No cgroup namespace created container:<id> - Using another container's cgroup namespace ns:<path> - A path to a cgroup namespace has been specified
    #[serde(rename = "CgroupMode", skip_serializing_if = "Option::is_none")]
    pub cgroup_mode: Option<String>,
    /// CgroupParent is the Cgroup parent of the container. Only set if not default.
    #[serde(rename = "CgroupParent", skip_serializing_if = "Option::is_none")]
    pub cgroup_parent: Option<String>,
    /// Cgroups contains the container's Cgroup mode. Allowed values are \"default\" (container is creating Cgroups) and \"disabled\" (container is not creating Cgroups). This is Libpod-specific and not included in `docker inspect`.
    #[serde(rename = "Cgroups", skip_serializing_if = "Option::is_none")]
    pub cgroups: Option<String>,
    /// ConsoleSize is an array of 2 integers showing the size of the container's console. It is only set if the container is creating a terminal. TODO.
    #[serde(rename = "ConsoleSize", skip_serializing_if = "Option::is_none")]
    pub console_size: Option<Vec<i32>>,
    /// ContainerIDFile is a file created during container creation to hold the ID of the created container. This is not handled within libpod and is stored in an annotation.
    #[serde(rename = "ContainerIDFile", skip_serializing_if = "Option::is_none")]
    pub container_id_file: Option<String>,
    /// CpuCount is Windows-only and not presently implemented.
    #[serde(rename = "CpuCount", skip_serializing_if = "Option::is_none")]
    pub cpu_count: Option<i32>,
    /// CpuPercent is Windows-only and not presently implemented.
    #[serde(rename = "CpuPercent", skip_serializing_if = "Option::is_none")]
    pub cpu_percent: Option<i32>,
    /// CpuPeriod is the length of a CPU period in microseconds. It relates directly to CpuQuota.
    #[serde(rename = "CpuPeriod", skip_serializing_if = "Option::is_none")]
    pub cpu_period: Option<i32>,
    /// CpuPeriod is the amount of time (in microseconds) that a container can use the CPU in every CpuPeriod.
    #[serde(rename = "CpuQuota", skip_serializing_if = "Option::is_none")]
    pub cpu_quota: Option<i64>,
    /// CpuRealtimePeriod is the length of time (in microseconds) of the CPU realtime period. If set to 0, no time will be allocated to realtime tasks.
    #[serde(rename = "CpuRealtimePeriod", skip_serializing_if = "Option::is_none")]
    pub cpu_realtime_period: Option<i32>,
    /// CpuRealtimeRuntime is the length of time (in microseconds) allocated for realtime tasks within every CpuRealtimePeriod.
    #[serde(rename = "CpuRealtimeRuntime", skip_serializing_if = "Option::is_none")]
    pub cpu_realtime_runtime: Option<i64>,
    /// CpuShares indicates the CPU resources allocated to the container. It is a relative weight in the scheduler for assigning CPU time versus other Cgroups.
    #[serde(rename = "CpuShares", skip_serializing_if = "Option::is_none")]
    pub cpu_shares: Option<i32>,
    /// CpusetCpus is the set of CPUs that the container will execute on. Formatted as `0-3` or `0,2`. Default (if unset) is all CPUs.
    #[serde(rename = "CpusetCpus", skip_serializing_if = "Option::is_none")]
    pub cpuset_cpus: Option<String>,
    /// CpusetMems is the set of memory nodes the container will use. Formatted as `0-3` or `0,2`. Default (if unset) is all memory nodes.
    #[serde(rename = "CpusetMems", skip_serializing_if = "Option::is_none")]
    pub cpuset_mems: Option<String>,
    /// Devices is a list of device nodes that will be added to the container. These are stored in the OCI spec only as type, major, minor while we display the host path. We convert this with /sys/dev, but we cannot guarantee that the host path will be identical - only that the actual device will be.
    #[serde(rename = "Devices", skip_serializing_if = "Option::is_none")]
    pub devices: Option<Vec<models::InspectDevice>>,
    /// DiskQuota is the maximum amount of disk space the container may use (in bytes). Presently not populated. TODO.
    #[serde(rename = "DiskQuota", skip_serializing_if = "Option::is_none")]
    pub disk_quota: Option<i32>,
    /// Dns is a list of DNS nameservers that will be added to the container's resolv.conf
    #[serde(rename = "Dns", skip_serializing_if = "Option::is_none")]
    pub dns: Option<Vec<String>>,
    /// DnsOptions is a list of DNS options that will be set in the container's resolv.conf
    #[serde(rename = "DnsOptions", skip_serializing_if = "Option::is_none")]
    pub dns_options: Option<Vec<String>>,
    /// DnsSearch is a list of DNS search domains that will be set in the container's resolv.conf
    #[serde(rename = "DnsSearch", skip_serializing_if = "Option::is_none")]
    pub dns_search: Option<Vec<String>>,
    /// ExtraHosts contains hosts that will be added to the container's etc/hosts.
    #[serde(rename = "ExtraHosts", skip_serializing_if = "Option::is_none")]
    pub extra_hosts: Option<Vec<String>>,
    /// GroupAdd contains groups that the user inside the container will be added to.
    #[serde(rename = "GroupAdd", skip_serializing_if = "Option::is_none")]
    pub group_add: Option<Vec<String>>,
    #[serde(rename = "IDMappings", skip_serializing_if = "Option::is_none")]
    pub id_mappings: Option<Box<models::InspectIdMappings>>,
    /// IOMaximumBandwidth is Windows-only and not presently implemented.
    #[serde(rename = "IOMaximumBandwidth", skip_serializing_if = "Option::is_none")]
    pub io_maximum_bandwidth: Option<i32>,
    /// IOMaximumIOps is Windows-only and not presently implemented.
    #[serde(rename = "IOMaximumIOps", skip_serializing_if = "Option::is_none")]
    pub io_maximum_i_ops: Option<i32>,
    /// Init indicates whether the container has an init mounted into it.
    #[serde(rename = "Init", skip_serializing_if = "Option::is_none")]
    pub init: Option<bool>,
    /// IntelRdtClosID defines the Intel RDT CAT Class Of Service (COS) that all processes of the container should run in.
    #[serde(rename = "IntelRdtClosID", skip_serializing_if = "Option::is_none")]
    pub intel_rdt_clos_id: Option<String>,
    /// IpcMode represents the configuration of the container's IPC namespace. Populated as follows: \"\" (empty string) - Default, an IPC namespace will be created host - No IPC namespace created container:<id> - Using another container's IPC namespace ns:<path> - A path to an IPC namespace has been specified
    #[serde(rename = "IpcMode", skip_serializing_if = "Option::is_none")]
    pub ipc_mode: Option<String>,
    /// Isolation is presently unused and provided solely for Docker compatibility.
    #[serde(rename = "Isolation", skip_serializing_if = "Option::is_none")]
    pub isolation: Option<String>,
    /// KernelMemory is the maximum amount of memory the kernel will devote to the container.
    #[serde(rename = "KernelMemory", skip_serializing_if = "Option::is_none")]
    pub kernel_memory: Option<i64>,
    /// Links is unused, and provided purely for Docker compatibility.
    #[serde(rename = "Links", skip_serializing_if = "Option::is_none")]
    pub links: Option<Vec<String>>,
    #[serde(rename = "LogConfig", skip_serializing_if = "Option::is_none")]
    pub log_config: Option<Box<models::InspectLogConfig>>,
    /// Memory indicates the memory resources allocated to the container. This is the limit (in bytes) of RAM the container may use.
    #[serde(rename = "Memory", skip_serializing_if = "Option::is_none")]
    pub memory: Option<i64>,
    /// MemoryReservation is the reservation (soft limit) of memory available to the container. Soft limits are warnings only and can be exceeded.
    #[serde(rename = "MemoryReservation", skip_serializing_if = "Option::is_none")]
    pub memory_reservation: Option<i64>,
    /// MemorySwap is the total limit for all memory available to the container, including swap. 0 indicates that there is no limit to the amount of memory available.
    #[serde(rename = "MemorySwap", skip_serializing_if = "Option::is_none")]
    pub memory_swap: Option<i64>,
    /// MemorySwappiness is the willingness of the kernel to page container memory to swap. It is an integer from 0 to 100, with low numbers being more likely to be put into swap. 1, the default, will not set swappiness and use the system defaults.
    #[serde(rename = "MemorySwappiness", skip_serializing_if = "Option::is_none")]
    pub memory_swappiness: Option<i64>,
    /// NanoCpus indicates number of CPUs allocated to the container. It is an integer where one full CPU is indicated by 1000000000 (one billion). Thus, 2.5 CPUs (fractional portions of CPUs are allowed) would be 2500000000 (2.5 billion). In 'docker inspect' this is set exclusively of two further options in the output (CpuPeriod and CpuQuota) which are both used to implement this functionality. We can't distinguish here, so if CpuQuota is set to the default of 100000, we will set both CpuQuota, CpuPeriod, and NanoCpus. If CpuQuota is not the default, we will not set NanoCpus.
    #[serde(rename = "NanoCpus", skip_serializing_if = "Option::is_none")]
    pub nano_cpus: Option<i64>,
    /// NetworkMode is the configuration of the container's network namespace. Populated as follows: default - A network namespace is being created and configured via CNI none - A network namespace is being created, not configured via CNI host - No network namespace created container:<id> - Using another container's network namespace ns:<path> - A path to a network namespace has been specified
    #[serde(rename = "NetworkMode", skip_serializing_if = "Option::is_none")]
    pub network_mode: Option<String>,
    /// OomKillDisable indicates whether the kernel OOM killer is disabled for the container.
    #[serde(rename = "OomKillDisable", skip_serializing_if = "Option::is_none")]
    pub oom_kill_disable: Option<bool>,
    /// OOMScoreAdj is an adjustment that will be made to the container's OOM score.
    #[serde(rename = "OomScoreAdj", skip_serializing_if = "Option::is_none")]
    pub oom_score_adj: Option<i64>,
    /// PidMode represents the configuration of the container's PID namespace. Populated as follows: \"\" (empty string) - Default, a PID namespace will be created host - No PID namespace created container:<id> - Using another container's PID namespace ns:<path> - A path to a PID namespace has been specified
    #[serde(rename = "PidMode", skip_serializing_if = "Option::is_none")]
    pub pid_mode: Option<String>,
    /// PidsLimit is the maximum number of PIDs that may be created within the container. 0, the default, indicates no limit.
    #[serde(rename = "PidsLimit", skip_serializing_if = "Option::is_none")]
    pub pids_limit: Option<i64>,
    /// PortBindings contains the container's port bindings. It is formatted as map[string][]InspectHostPort. The string key here is formatted as <integer port number>/<protocol> and represents the container port. A single container port may be bound to multiple host ports (on different IPs).
    #[serde(rename = "PortBindings", skip_serializing_if = "Option::is_none")]
    pub port_bindings: Option<std::collections::HashMap<String, Vec<models::InspectHostPort>>>,
    /// Privileged indicates whether the container is running with elevated privileges. This has a very specific meaning in the Docker sense, so it's very difficult to decode from the spec and config, and so is stored as an annotation.
    #[serde(rename = "Privileged", skip_serializing_if = "Option::is_none")]
    pub privileged: Option<bool>,
    /// PublishAllPorts indicates whether image ports are being published. This is not directly stored in libpod and is saved as an annotation.
    #[serde(rename = "PublishAllPorts", skip_serializing_if = "Option::is_none")]
    pub publish_all_ports: Option<bool>,
    /// ReadonlyRootfs is whether the container will be mounted read-only.
    #[serde(rename = "ReadonlyRootfs", skip_serializing_if = "Option::is_none")]
    pub readonly_rootfs: Option<bool>,
    #[serde(rename = "RestartPolicy", skip_serializing_if = "Option::is_none")]
    pub restart_policy: Option<Box<models::InspectRestartPolicy>>,
    /// Runtime is provided purely for Docker compatibility. It is set unconditionally to \"oci\" as Podman does not presently support non-OCI runtimes.
    #[serde(rename = "Runtime", skip_serializing_if = "Option::is_none")]
    pub runtime: Option<String>,
    /// SecurityOpt is a list of security-related options that are set in the container.
    #[serde(rename = "SecurityOpt", skip_serializing_if = "Option::is_none")]
    pub security_opt: Option<Vec<String>>,
    #[serde(rename = "ShmSize", skip_serializing_if = "Option::is_none")]
    pub shm_size: Option<i64>,
    /// Tmpfs is a list of tmpfs filesystems that will be mounted into the container. It is a map of destination path to options for the mount.
    #[serde(rename = "Tmpfs", skip_serializing_if = "Option::is_none")]
    pub tmpfs: Option<std::collections::HashMap<String, String>>,
    /// UTSMode represents the configuration of the container's UID namespace. Populated as follows: \"\" (empty string) - Default, a UTS namespace will be created host - no UTS namespace created container:<id> - Using another container's UTS namespace ns:<path> - A path to a UTS namespace has been specified
    #[serde(rename = "UTSMode", skip_serializing_if = "Option::is_none")]
    pub uts_mode: Option<String>,
    /// Ulimits is a set of ulimits that will be set within the container.
    #[serde(rename = "Ulimits", skip_serializing_if = "Option::is_none")]
    pub ulimits: Option<Vec<models::InspectUlimit>>,
    /// UsernsMode represents the configuration of the container's user namespace. When running rootless, a user namespace is created outside of libpod to allow some privileged operations. This will not be reflected here. Populated as follows: \"\" (empty string) - No user namespace will be created private - The container will be run in a user namespace container:<id> - Using another container's user namespace ns:<path> - A path to a user namespace has been specified TODO Rootless has an additional 'keep-id' option, presently not reflected here.
    #[serde(rename = "UsernsMode", skip_serializing_if = "Option::is_none")]
    pub userns_mode: Option<String>,
    /// VolumeDriver is presently unused and is retained for Docker compatibility.
    #[serde(rename = "VolumeDriver", skip_serializing_if = "Option::is_none")]
    pub volume_driver: Option<String>,
    /// VolumesFrom is a list of containers which this container uses volumes from. This is not handled directly within libpod and is stored in an annotation. It is formatted as an array of container names and IDs.
    #[serde(rename = "VolumesFrom", skip_serializing_if = "Option::is_none")]
    pub volumes_from: Option<Vec<String>>,
}

impl InspectContainerHostConfig {
    /// nolint:revive,stylecheck // Field names are fixed for compatibility and cannot be changed.
    pub fn new() -> InspectContainerHostConfig {
        InspectContainerHostConfig {
            annotations: None,
            auto_remove: None,
            binds: None,
            blkio_device_read_bps: None,
            blkio_device_read_i_ops: None,
            blkio_device_write_bps: None,
            blkio_device_write_i_ops: None,
            blkio_weight: None,
            blkio_weight_device: None,
            cap_add: None,
            cap_drop: None,
            cgroup: None,
            cgroup_conf: None,
            cgroup_manager: None,
            cgroup_mode: None,
            cgroup_parent: None,
            cgroups: None,
            console_size: None,
            container_id_file: None,
            cpu_count: None,
            cpu_percent: None,
            cpu_period: None,
            cpu_quota: None,
            cpu_realtime_period: None,
            cpu_realtime_runtime: None,
            cpu_shares: None,
            cpuset_cpus: None,
            cpuset_mems: None,
            devices: None,
            disk_quota: None,
            dns: None,
            dns_options: None,
            dns_search: None,
            extra_hosts: None,
            group_add: None,
            id_mappings: None,
            io_maximum_bandwidth: None,
            io_maximum_i_ops: None,
            init: None,
            intel_rdt_clos_id: None,
            ipc_mode: None,
            isolation: None,
            kernel_memory: None,
            links: None,
            log_config: None,
            memory: None,
            memory_reservation: None,
            memory_swap: None,
            memory_swappiness: None,
            nano_cpus: None,
            network_mode: None,
            oom_kill_disable: None,
            oom_score_adj: None,
            pid_mode: None,
            pids_limit: None,
            port_bindings: None,
            privileged: None,
            publish_all_ports: None,
            readonly_rootfs: None,
            restart_policy: None,
            runtime: None,
            security_opt: None,
            shm_size: None,
            tmpfs: None,
            uts_mode: None,
            ulimits: None,
            userns_mode: None,
            volume_driver: None,
            volumes_from: None,
        }
    }
}

